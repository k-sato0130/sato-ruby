### Array Class

## 配列に要素を追加する
arr = [0, 1]
p arr.concat([2, 3]) #=> [0, 1, 2, 3]
p arr.insert(1, 9) #=> [0, 9, 1, 2, 3]
p arr.unshift(10) #=> [10, 0, 9, 1, 2, 3]

## 配列の要素を参照する
arr2 = [1, 2, 3, 4]
p arr2.at(1) #=> 2
p arr2.values_at(1) #=> [2] #結果を配列で返す
p arr2.fetch(2) #=> 3

## 配列の要素を削除する
arr3 = [0, 1, 2, 3, 4, 5]
arr4 = [0, 1, 2, 3, 4, 5]
arr3.delete_at(2)
p arr3 #=> [0, 1, 3, 4, 5]
p arr3.clear #=> []
p arr4.delete_if{ |n| n%2 == 0 } #=> [1, 3, 5] #2の約数なら削除
p arr4.pop(1) #=>[5] #後ろから1つ
p arr4.shift(1) #=> [1] #前から１つ
p arr4 #=> [3]

## 配列要素での繰り返し
arr5 = [1, 3, 5, 7, 9]
arr5.each_index { |n| puts n*2 } #=> 0 2 4 6 8
#**arr5.cycle { |n| puts n } #=> 永遠の繰り返し

## 配列をソートする。
arr6 = [4, 9, 5, 2, 6]
p arr6.sort #=> [2, 4, 5, 6, 9]
#arr6.sort{ |a, b| a <=> b }で評価され、１つ目の要素が大きく、０であれば同じ、負の整数であれば２つ目の要素が大きいとしてソートされる。
p 10 <=> 11 #=> -1
p 11 <=> 11 #=> 0
p 12 <=> 11 #=> 1

## 配列を組み合わせて生成する
p [1, 2].product(["a", "b"]) #=> [[1, "a"], [1, "b"], [2, "a"], [2, "b"]]
p [1 ,2].zip(["a", "b"]) #=>[[1, "a"], [2, "b"]]
